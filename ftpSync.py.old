def ftpConnect(server, user, password, port):
    logger("Opening FTP Connection at: " + datetime.datetime.now().strftime("%Y-%m-%d %H:%M") + "\n")
    ftp = FTP()
    ftp.connect(server, int(port))
    ftp.login(user, password)
    return ftp

def checkRemoteFiles(server, user, password, port, remoteFolder):
    listOfFiles = []
    ftp = ftpConnect(server, user, password, port)
    ftp.cwd(remoteFolder)
    
    logger("Create Remote File List:\n")
    
    try:
        files = ftp.nlst()
    except ftplib.error_perm as resp: #TODO: add more cases here
        if str(resp) == "550 No files found":
            logger("No files in this directory -- 550 No files found" + "\n")
        else:
            raise

    for f in files:
        logger("Adding remote file: " + f + "\n")
        listOfFiles.append(f)
    
    logger("Closing FTP Connection" + "\n")
    ftp.close()
    return listOfFiles


def fileDownload(ftpConnection, fileName, destination):
    try:
        ftpConnection.sendcmd("TYPE i")
        logger("Downloading file: " + fileName + " " + str(ftpConnection.size(fileName) / 1000 / 1000) + "MB\n")
        file = open(fileName, 'wb')
        
        ftpConnection.retrbinary('RETR '+ fileName, file.write)
        file.close()
        fileMove(fileName, destination)

    except Exception as e:
        logger("Exception: " + str(e) + "\n")

def fileMove(fileName, destination):
    try:
        logger("Moving downloaded file: " + fileName + " to: " + destination + "/" + fileName + "\n")
        shutil.move(fileName, destination + "/" + fileName)

    except Exception as e:
        logger("Exception: " + str(e) + "\n")

def downloadMissingFiles(server, user, password, port, missingFiles, sourceFolder, destinationFolder):
    logger("Beginning Downloads at: " + datetime.datetime.now().strftime("%Y-%m-%d %H:%M") + "\n")
    ftp = ftpConnect(server, user, password, port)
    ftp.cwd(sourceFolder)
    
    for f in missingFiles:
        ftp.cwd(sourceFolder + "/" + f)
        filenames = []
        ftp.retrlines('NLST', filenames.append)
        
        if(os.path.isdir(destinationFolder + "/" + f) == False):
            os.mkdir(destinationFolder + "/" + f)
        else:
            logger("Unable to create directory: " + destinationFolder + "/" + f + " already exists.\n")

        for filename in filenames:
            try:
                ftp.cwd(filename)
            except ftplib.error_perm:
                return

            allowedRegEx = re.compile("\.(rar|iso|zip|z[0-9]{2}|r[0-9]{2}|s[0-9]{2})$")
            disallowedRegEx = re.compile("\.(nfo|sfv|mp4|avi|mkv)$")

            if(allowedRegEx.search(filename) != None): # the file we're on is not a directory, let's download the file
                print("File to download: ", filename)
                # local_filename = os.path.join(destinationFolder + "/" + f, filename)
                logger("Attempting To Download: " + local_filename + "\n")
                
                if(os.path.exists(local_filename) == False):
                    fileDownload(ftp, filename, destinationFolder + "/" + f)
                else:
                    #TODO: add logic to compare remote/local files and delete or move on, log which happens
                    logger("Unable to download file: " + local_filename + " already exists.\n")
            elif(disallowedRegEx.search(filename)): #not an allowed download, skip this round
                print("File to not download: " + filename)
                continue
            else: #we need to create another directory
                subfiles = []
                # if(os.path.isdir(destinationFolder + "/" + f + "/" + filename)):
                #     logger("Unable to create directory: " + destinationFolder + "/" + f + "/" + filename + " directory already exists.\n")
                # else:
                    # os.mkdir(destinationFolder + "/" + f + "/" + filename)
                    # logger("Attempting to create: " + destinationFolder + "/" + f + "/" + filename + "\n")
                print("CWD: " + sourceFolder + "/" + f + "/" + filename)
                ftp.cwd(sourceFolder + "/" + f + "/" + filename)
                ftp.retrlines('NLST', subfiles.append)
                for subfile in subfiles:
                    if(allowedRegEx.search(subfile)):
                        print("Downloadable?: " + subfile)
                            sub_local_filename = os.path.join(destinationFolder + "/" + f + "/" + filename, subfile)
                            logger("Attempting To Download: " + sub_local_filename + "\n")
                            
                            if(os.path.exists(sub_local_filename) == False):
                                fileDownload(ftp, sub_local_filename, destinationFolder + "/" + f)

                            else:
                                logger("Unable to download file: " + sub_local_filename + " already exists.\n")


    logger("Closing FTP Connection at: " + datetime.datetime.now().strftime("%Y-%m-%d %H:%M") + "\n")
    ftp.close()

def iterateThroughDirectory(directory):
    directories = set(folder for folder, subfolders, files in os.walk(directory) for file_ in files if os.path.splitext(file_)[1] == '.rar')
    
    for dir in directories:
        os.chdir(os.path.realpath(dir))
        bashExtractCommand = "unrar x " + os.getcwd().replace(" ", "\ ") + "/*.rar"
        bashRemoveCommand = "rm -rf " + os.getcwd().replace(" ", "\ ") + "/*.r*"
        logger("Running: " + bashExtractCommand + "\n")
        process = subprocess.Popen(bashExtractCommand, shell=True, stdout=subprocess.PIPE)
        output = process.communicate()[0]
    
    for dir in directories:    
        logger("Removing: rar archives from: " + os.getcwd().replace(" ", "\ ") + "\n")
        process = subprocess.Popen(bashRemoveCommand, shell=True, stdout=subprocess.PIPE)
        output = process.communicate()[0]



def cleanupDownloadsFolder(downloadsFolder):
    iterateThroughDirectory(downloadsFolder)

def checkLocalFiles(localPath):
    directories = [d for d in os.listdir(localPath) if os.path.isdir(os.path.join(localPath, d))]
    dirs = []
    for d in directories:
        dirs.append(d)

    return dirs

def findMissingFiles(localList, remoteList):
    return [i for i in remoteList if i not in localList]

    def iterateThroughDirectory():
        directories = set(folder for folder, subfolders, files in os.walk(self.localDirectoryToSync) for file_ in files if os.path.splitext(file_)[1] == '.rar')
        
        for dir in directories:
            os.chdir(os.path.realpath(dir))
            bashExtractCommand = "unrar x " + os.getcwd().replace(" ", "\ ") + "/*.rar"
            bashRemoveCommand = "rm -rf " + os.getcwd().replace(" ", "\ ") + "/*.r*"
            logger("Running: " + bashExtractCommand)
            process = subprocess.Popen(bashExtractCommand, shell=True, stdout=subprocess.PIPE)
            output = process.communicate()[0]
        
        for dir in directories:    
            logger("Removing: rar archives from: " + os.getcwd().replace(" ", "\ "))
            process = subprocess.Popen(bashRemoveCommand, shell=True, stdout=subprocess.PIPE)
            output = process.communicate()[0]

    def cleanupDownloadsFolder(downloadsFolder):
        iterateThroughDirectory(downloadsFolder)

    def checkRemoteFiles():
        listOfFiles = []
        
        self.ftpConnection = self.createFtpConnection()
        self.ftpConnection.cwd(self.remoteDirectoryToSync)
        
        logger("Creating Remote File List:")
        
        try:
            files = self.ftpConnection.nlst()
        except ftplib.error_perm, resp:
            if str(resp) == "550 No files found":
                logger("No files in this directory -- 550 No files found")
            else:
                raise

        for f in files:
            logger("Adding remote file: " + f)
            listOfFiles.append(f)
        
        logger("Closing FTP Connection")
        self.closeFtpConnection()

        return listOfFiles

    def fileDownload(fileName, destination):
        logger("Downloading file: " + fileName + "\n")
        file = open(fileName, 'wb')
        
        self.ftpConnection.retrbinary('RETR '+ fileName, file.write)
        file.close()

        logger("Moving downloaded file: " + fileName + " to: " + destination + "/" + fileName + "\n")
        shutil.move(fileName, destination + "/" + fileName)

    def findMissingFiles(localList, remoteList):
        return [i for i in remoteList if i not in localList]

    def logger(message):
        if(os.path.isdir("Logs") == False):
            os.mkdir("Logs")

        LOG_FILENAME = "Logs/" + datetime.datetime.now().strftime("%Y-%m-%d") + ".log"
        logging.basicConfig(filename=LOG_FILENAME,level=logging.DEBUG)
        logging.debug(message)


class DirEntry: # found at: http://www.java2s.com/Tutorial/Python/0420__Network/nlstwithfiledirectorydetectionexample.htm
    def __init__(self, filename, ftpobj, startingdir = None):
        self.filename = filename
        if startingdir == None:
            startingdir = ftpobj.pwd()
        try:
            ftpobj.cwd(filename)
            self.filetype = 'd'
            ftpobj.cwd(startingdir)
        except ftplib.error_perm:
            self.filetype = '-'
        
    def gettype(self):
        return self.filetype

    def getfilename(self):
        return self.filename

class FileSyncer:
    ftpConnection = None
    ftpUser = ""
    ftpPassword = ""
    ftpServer = ""
    ftpPort = 21
    remoteDirectoryToSync = ""
    localDirectoryToSync = ""
    subScans = 0
    currentWorkingDirectory = ""
    directories = {}

    def __init__(self, server, user, password, port, remoteDirectory, localDirectory):
        self.ftpServer = server
        self.ftpUser = user
        self.ftpPassword = password
        self.ftpPort = port
        self.remoteDirectoryToSync = remoteDirectory
        self.localDirectoryToSync = localDirectory

    def createFtpConnection(self):
        logger("Opening FTP Connection at: " + datetime.datetime.now().strftime("%Y-%m-%d %H:%M"))
        ftp = FTP()
        ftp.connect(asP{})
        ftp.login(self.ftpUser, self.ftpPassword)
        return ftp

    def closeFtpConnection(self, ftpConnection):
        logger("Closing FTP Connection")
        ftpConnection.close()

    def findMissingFiles(self, localList, remoteList):
        

    def checkLocalFiles(self):
        return [d for d in os.listdir(self.localDirectoryToSync) if os.path.isdir(os.path.join(self.localDirectoryToSync, d))]

    def moveFile(self, fileName, destination):
        try:
            logger("Moving downloaded file: " + fileName + " to: " + destination + "/" + fileName + "\n")
            shutil.move(fileName, self.localDirectoryToSync + "/" + destination + "/" + fileName)

        except Exception as e:
            logger("Exception: " + str(e) + "\n")

    def createLocalDirectory(self, folderToCreate):
        try:
            if(os.path.isdir(self.localDirectoryToSync + "/" + folderToCreate) == False):
                os.mkdir(self.localDirectoryToSync + "/" + folderToCreate)
            else:
                logger("Unable to create directory: " + self.localDirectoryToSync + "/" + folderToCreate + " already exists.\n")

        except Exception as e:
            logger("Error creating local directory: " + e)

    def checkRemoteFiles(self):
        listOfFiles = []

        try:
            ftp = self.createFtpConnection()
            ftp.cwd(self.remoteDirectoryToSync)
            
            logger("Create Remote File List:\n")
            ftp.retrlines('NLST', listOfFiles.append)
            self.closeFtpConnection(ftp)
        
        except Exception as resp: #TODO: add more cases here
            if str(resp) == "550 No files found":
                logger("No files in this directory -- 550 No files found" + "\n")
            else:
                raise
        
        return listOfFiles

    def checkForDirectories(self, objFtp, fileToScan):
        hasSubDirectories = False
        for singleFile in fileToScan:
            if(self.isDirectory(objFtp, singleFile) == True): #We have a sub directory
                hasSubDirectories = True

        return hasSubDirectories

    def downloadFolder(self, objFtp, folderToScan):
        fileNames = []
        
        try:
            # self.createLocalDirectory(folderToScan)
            
            if self.currentWorkingDirectory == "":
                objFtp.cwd(self.remoteDirectoryToSync + "/" + folderToScan)
            else:
                objFtp.cwd(self.currentWorkingDirectory + "/" + folderToScan)
            
            objFtp.retrlines('NLST', fileNames.append)
            
            for f in fileNames:
                print("cwd is: " + objFtp.pwd() + " and file is: " + f)
                if(self.isDirectory(objFtp, f)):
                    print(f + " is a directory")
                    self.subScans += 1
                    if(self.checkForDirectories(objFtp, f) == True):
                        self.currentWorkingDirectory = objFtp.pwd()
                        self.downloadFolder(objFtp, f)
                    else:
                        print("i am here again doing something else")
                else:
                    print("i am here downloading a single file")
                    # self.downloadFile(objFtp, folderToScan, f)
        
        except Exception as e:
            logger("Folder scan exception: " + str(e))

    def downloadFile(self, objFtp, destinationFolder, fileToDownload):
        try:
            objFtp.sendcmd("TYPE i")
            logger("Downloading file: " + fileToDownload + " " + str(objFtp.size(fileToDownload) / 1024 / 1024) + "MB\n")
            file = open(fileToDownload, 'wb')
            objFtp.retrbinary('RETR '+ fileToDownload, file.write)
            file.close()
            self.moveFile(fileToDownload, destinationFolder)

        except Exception as e:
            logger("Failed file download:" + fileToDownload)
        

    def isDirectory(self, objFtp, fileToCheck):
        try:
            objFtp.cwd(self.remoteDirectoryToSync + "/" + fileToCheck)
            isASubDirectory = True

        except Exception as e:
            isASubDirectory = False

        return isASubDirectory

    def downloadMissingFiles(self, missingFiles):
        logger("Beginning Downloads at: " + datetime.datetime.now().strftime("%Y-%m-%d %H:%M") + "\n")
        try:
            ftp = self.createFtpConnection()
            ftp.cwd(self.remoteDirectoryToSync)

            for f in missingFiles:
                fileNames = []
                ftp.cwd(self.remoteDirectoryToSync + "/" + f)
                ftp.retrlines('NLST', fileNames.append)
                self.downloadFolder(ftp, f)
        except Exception as e:
            logger("Exception: " + str(e))

        self.closeFtpConnection(ftp)